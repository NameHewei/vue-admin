<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>test</title>
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
    <style>
        .set-frequency-part{
            width: 195px;
            background-color: red;
        }
        .set-frequency-part input{
            width: 80px;
            margin: 0 5px;
            border: 1px solid rgb(192, 192, 192);
        }
        .sf-txt{
            margin: 6px 0 2px;
        }
        .sf-btn{
            margin: 20px 0 5px;
        }
        .sf-btn button:last-child {
            float: right;
        }
    </style>
</head>

<div>
    <div class="set-frequency-part">
        <div>
            <div class="sf-txt">低频区间</div>
            <div><input type="number">-<input type="number"></div>
        </div>
        <div>
            <div class="sf-txt">高频区间</div>
            <div><input type="number">-<input type="number"></div>
        </div>
        <div class="sf-btn">
            <button>恢复默认</button>
            <button>确认</button>
        </div>
    </div>
    <script>

        let quickTopK = function (arr, k) {
            if(k==0)return []
            if (arr.length < 2) return arr
            let midValue = arr.splice(0, 1), left = [], right = []
            arr.forEach((el) => {
                el > midValue ? left.push(el) : right.push(el)
            });
            if (left.length == k) {
                return left
            } else if (left.length > k) {
                return quickTopK(left, k)
            } else {
                return left.concat(midValue, quickTopK(right, k - left.length - 1))
            }
        }

        function topTen(arr)　{
            const ten = [], tenIndex=[0,1,2,3,4,5,6,7,8,9], len = arr.length;
            function compareTen(val, index) {
                if(ten.length === 0) {
                    ten.push(val);
                    tenIndex.push(index)
                    return
                }
                for (let i = 0; i < 10; i++) {
                    if(val > ten[i]) { 
                        ten.splice(i, 1, val)
                        tenIndex.splice(i, 1, index)
                    }
                }
            }
            for (let i = 10; i < len; i++) {
                compareTen(arr[i], i)
            }

            return [ten, tenIndex]
        }


        function findPeak(arr) {
            // 满足一阶导数为0，并且满足二阶导数为负；而波谷点，则满足一阶导数为0，二阶导数为正
            const peak = []
            const peakIndex = []
            const len = arr.length
            const tempArr = []
            
            // 一阶求导,获取每个点的斜率
            for (let i = 0; i < len; i++){
                if (arr[i + 1] - arr[i]>0) {
                    // 表示向上倾斜，斜率为正
                    tempArr[i] = 1;
                } else if (arr[i + 1] - arr[i] < 0){
                    // 表示向下倾斜，斜率为负
                    tempArr[i] = -1;
                } else {
                    // 出现了水平线，或是超过了数组边界
                    tempArr[i] = 0;
                }
            }
            // 处理水平的点位
            for (let i = len - 1; i >= 0; i--) {
                // 判断最后一个数是不是0
                if (tempArr[i] == 0 && i == len - 1){
                    tempArr[i] = 1;
                } else if (tempArr[i] == 0){
                    if (tempArr[i + 1] >= 0) { 
                        // 将水平位置的点斜率设置为向上 
                        tempArr[i] = 1;
                    } else{
                        // 将水平位置的点斜率设置为向下
                        tempArr[i] = -1;
                    }
                }
            }

            for (i = 0; i < len; i++){
                // 当 i+1 为波峰时，其对应的值减去 i 个值必为 -2
                if (tempArr[i + 1] - tempArr[i] == -2) {
                    peak.push(arr[i + 1])
                    peakIndex.push(i + 1)
                }
            }
            return [peak,peakIndex]
        }
        const arr = [-5,10,9,14,14,8,25,9,5,16,7]

        const peakAndIndex = findPeak(arr)
        const sortT = [].concat(peakAndIndex[0]).sort(function(a, b){ return a-b }) //10 14 25 16

        const newIndex = []
        
        for (let i = 0; i < sortT.length; i++) {
            for (let k = 0; k < peakAndIndex[0].length; k++) {
                if(sortT[i] === peakAndIndex[0][k]) {
                    newIndex.push(peakAndIndex[1][k])
                }
            }
        }
        
        console.log('origin', peakAndIndex)
        console.log('index', newIndex)
        console.log('sort', sortT)
    </script>
    </body>

</html>